<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Продвинутый WebRTC чат с E2E шифрованием</title>
    <!-- Библиотека для потокового хэширования -->
    <script src="https://cdn.jsdelivr.net/npm/js-sha256@0.9.0/src/sha256.js"></script>
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1e1e1e; --primary-text: #e0e0e0;
            --secondary-text: #a0a0a0; --border-color: #333333; --accent-blue: #0d6efd;
            --accent-green: #198754; --accent-red: #dc3545; --accent-orange: #fd7e14;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color); color: var(--primary-text); margin: 0; padding: 20px;
        }
        h1, h2 { color: var(--primary-text); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; width: 100%; text-align: center; }
        #app-container { display: flex; flex-direction: column; gap: 20px; align-items: center; max-width: 600px; width: 100%; }
        .card { padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--surface-color); width: 100%; box-sizing: border-box; }
        textarea {
            width: 98%; min-height: 120px; margin: 10px auto; padding: 8px; font-size: 0.9em; display: block;
            background-color: #2a2a2a; color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; word-break: break-all;
        }
        input[type="text"], input[type="file"] { width: 98%; padding: 8px; box-sizing: border-box; margin-top: 5px; background-color: #2a2a2a; color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 4px;}
        button {
            font-size: 1em; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer;
            background-color: var(--accent-blue); color: white; margin: 5px; transition: background-color 0.2s; width: 100%; box-sizing: border-box;
        }
        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        #status-bar { margin: 20px 0; text-align: center; }
        #status { font-size: 1.2em; font-weight: bold; color: var(--accent-orange); transition: color 0.3s; }
        audio { margin-top: 10px; border: 1px solid var(--border-color); border-radius: 8px; width: 100%; }
        #volume-controls div { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; }
        #in-call-info { text-align: center; font-size: 1.1em; color: var(--accent-green); }

        /* --- Chat Styles --- */
        #chat-area { display: flex; flex-direction: column; gap: 12px; height: 300px; overflow-y: auto; padding: 10px; background-color: #2a2a2a; border-radius: 4px; }
        .message-bubble { display: flex; flex-direction: column; max-width: 80%; padding: 10px 15px; border-radius: 18px; position: relative; }
        .message-content { word-wrap: break-word; }
        .message-meta { font-size: 0.75em; color: var(--secondary-text); margin-top: 5px; display: flex; justify-content: space-between; align-items: center; }
        .copy-btn { cursor: pointer; opacity: 0.5; transition: opacity 0.2s; margin-left: 10px; }
        .copy-btn:hover { opacity: 1; }
        .my-message { align-self: flex-end; background-color: var(--accent-blue); color: white; }
        .peer-message { align-self: flex-start; background-color: #363636; }

        /* --- File Transfer Styles --- */
        #file-transfer-controls { display: flex; gap: 10px; }
        #progress-bar-container { width: 100%; background-color: #333; border-radius: 5px; margin-top: 10px; }
        #progress-bar { width: 0%; height: 20px; background-color: var(--accent-green); border-radius: 5px; text-align: center; line-height: 20px; color: white; transition: width 0.1s; }
        #file-transfer-info { font-size: 0.9em; margin-top: 5px; color: var(--secondary-text); }
        #file-transfer-info a { color: var(--accent-blue); }
        #call-actions { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        .action-buttons button { flex-grow: 1; }
    </style>
</head>
<body>
    <h1>Продвинутый WebRTC чат с E2E шифрованием</h1>
    <div id="status-bar"><div id="status">Статус: Готов к работе</div></div>

    <div id="app-container">
        <div class="card">
            <h2>Ваш никнейм</h2>
            <input type="text" id="nicknameInput" placeholder="Введите ваш никнейм...">
        </div>

        <div id="connection-card" class="card">
            <h2>Подключение</h2>
            <button id="createRequestBtn">Создать запрос на звонок</button>
            <textarea id="signalingCodeText" placeholder="Вставьте сюда код от собеседника..."></textarea>
        </div>

        <div id="in-call-controls" class="card" hidden>
            <h2 id="in-call-info">Идет звонок...</h2>
            <div id="volume-controls">
                <div>
                    <label for="sendVolume">Громкость отправки:</label>
                    <input type="range" id="sendVolume" min="0" max="1000" value="100">
                    <span id="sendVolumeValue">100%</span>
                </div>
                <div>
                    <label for="receiveVolume">Громкость приема:</label>
                    <input type="range" id="receiveVolume" min="0" max="1000" value="100">
                    <span id="receiveVolumeValue">100%</span>
                </div>
            </div>
            <audio id="remoteAudio" autoplay></audio>

            <div id="chat-container">
                <h2>Чат</h2>
                <div id="chat-area"></div>
                <input type="text" id="chatInput" placeholder="Введите сообщение...">
                <button id="sendMsgBtn">Отправить</button>
            </div>

            <div id="file-transfer-container">
                <h2>Передача файлов</h2>
                <input type="file" id="fileInput">
                <div id="file-transfer-controls">
                    <button id="sendFileBtn">Отправить файл</button>
                    <button id="cancelFileTransferBtn" style="background-color: var(--accent-orange);" hidden>Отмена</button>
                </div>
                <div id="progress-bar-container">
                    <div id="progress-bar">0%</div>
                </div>
                <div id="file-transfer-info"></div>
            </div>
            
            <div id="call-actions">
                <button id="toggleMuteBtn" style="background-color: var(--accent-green);">Выключить микрофон</button>
                <button id="disconnectBtn" style="background-color: var(--accent-red);">Завершить звонок</button>
            </div>
        </div>
    </div>

<script>
    // --- DOM Elements & Global State ---
    const nicknameInput = document.getElementById('nicknameInput'), statusEl = document.getElementById('status'),
          createRequestBtn = document.getElementById('createRequestBtn'), signalingCodeText = document.getElementById('signalingCodeText'),
          inCallControlsEl = document.getElementById('in-call-controls'), connectionCardEl = document.getElementById('connection-card'),
          inCallInfoEl = document.getElementById('in-call-info'), remoteAudio = document.getElementById('remoteAudio'),
          disconnectBtn = document.getElementById('disconnectBtn'), sendVolumeSlider = document.getElementById('sendVolume'),
          receiveVolumeSlider = document.getElementById('receiveVolume'), sendVolumeValue = document.getElementById('sendVolumeValue'),
          receiveVolumeValue = document.getElementById('receiveVolumeValue'), chatArea = document.getElementById('chat-area'),
          chatInput = document.getElementById('chatInput'), sendMsgBtn = document.getElementById('sendMsgBtn'),
          fileInput = document.getElementById('fileInput'), sendFileBtn = document.getElementById('sendFileBtn'),
          cancelFileTransferBtn = document.getElementById('cancelFileTransferBtn'),
          progressBar = document.getElementById('progress-bar'), fileTransferInfo = document.getElementById('file-transfer-info'),
          toggleMuteBtn = document.getElementById('toggleMuteBtn');

    // Используем только проверенный STUN-сервер, как и было изначально.
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let peerConnection, localStream, dataChannel, connectionTimeout;
    let audioContext, localGainNode, remoteStreamSource, remoteGainNode;
    let incomingFileInfo = {}, transferStartTime, fileWriter, receivedFileHandle;
    let receivedSize = 0, receiveBuffer = [];
    let isMuted = false;
    let isTransferCancelled = false;
    let currentDownloadUrl = null;
    const CHUNK_SIZE = 64 * 1024;
    
    // --- E2EE Crypto State ---
    let myIdentityKeys;
    let peerIdentityKey;
    let cryptoReady = false;
    const ECDH_PARAMS = { name: 'ECDH', namedCurve: 'P-256' };
    const AES_PARAMS = { name: 'AES-GCM', length: 256 };
    const HKDF_PARAMS = { name: 'HKDF', hash: 'SHA-256' };
    const EPHEMERAL_KEY_LENGTH = 65; // Uncompressed P-256 public key
    const IV_LENGTH = 12; // AES-GCM recommended nonce length

    // --- Initialization ---
    window.addEventListener('load', () => {
        nicknameInput.value = localStorage.getItem('nickname') || '';
        sendVolumeSlider.value = localStorage.getItem('sendVolume') || '100';
        receiveVolumeSlider.value = localStorage.getItem('receiveVolume') || '100';
        handleSendVolumeChange(); handleReceiveVolumeChange();
    });
    window.addEventListener('beforeunload', revokeDownloadLink);
    nicknameInput.addEventListener('change', () => localStorage.setItem('nickname', nicknameInput.value));

    // --- Core WebRTC Logic ---
    async function initializePeerConnection() {
        if (peerConnection) peerConnection.close();
        peerConnection = new RTCPeerConnection(configuration);

        // ИЗМЕНЕНИЕ №1: Вешаем все обработчики СРАЗУ при инициализации,
        // до того, как будут созданы offer или answer.
        peerConnection.ontrack = event => {
            remoteAudio.srcObject = event.streams[0];
            setupRemoteAudioProcessing(event.streams[0]);
        };
        peerConnection.ondatachannel = event => {
            dataChannel = event.channel;
            setupDataChannelHandlers();
        };
        peerConnection.onconnectionstatechange = () => {
            const state = peerConnection.connectionState;
            statusEl.textContent = `Статус: ${state}`;
            if (state === 'connected') {
                clearTimeout(connectionTimeout);
                statusEl.style.color = 'var(--accent-green)';
                connectionCardEl.hidden = true; inCallControlsEl.hidden = false;
            } else if (['disconnected', 'failed', 'closed'].includes(state)) {
                forceDisconnect();
            }
        };
        
        // Запрашиваем доступ к микрофону
        await setupLocalMedia();
    }

    createRequestBtn.onclick = async () => {
        if (!nicknameInput.value) return alert('Пожалуйста, введите ваш никнейм.');
        try {
            await initializePeerConnection();
            dataChannel = peerConnection.createDataChannel("data", { ordered: true });
            setupDataChannelHandlers();

            // ИЗМЕНЕНИЕ №2: Назначаем обработчик onicecandidate ДО вызова setLocalDescription.
            // Теперь он гарантированно сработает.
            peerConnection.onicecandidate = e => {
                // Ждем, пока сбор кандидатов не завершится (e.candidate будет null)
                if (e.candidate) return;
                
                // Как только сбор завершен, peerConnection.localDescription содержит ВСЕ кандидаты.
                // Копируем готовый код приглашения.
                navigator.clipboard.writeText(btoa(JSON.stringify({ type: 'offer', sdp: peerConnection.localDescription })));
                statusEl.textContent = 'Код приглашения скопирован. Отправьте его.';
            };
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer); // Этот вызов запускает сбор кандидатов

        } catch (err) { console.error("Failed to create offer:", err); }
    };

    signalingCodeText.addEventListener('input', async () => {
        const code = signalingCodeText.value;
        if (code.length < 50) return;
        let payload;
        try { payload = JSON.parse(atob(code)); } catch { return; }
        
        if (payload.type === 'offer') {
            try {
                await initializePeerConnection();
                
                // ИЗМЕНЕНИЕ №3: Точно такая же логика для отвечающего.
                // Назначаем обработчик ЗАРАНЕЕ.
                peerConnection.onicecandidate = e => {
                    if (e.candidate) return;
                    navigator.clipboard.writeText(btoa(JSON.stringify({ type: 'answer', sdp: peerConnection.localDescription })));
                    statusEl.textContent = 'Ответ создан и скопирован.';
                };

                await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.sdp));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer); // Запускаем сбор кандидатов

            } catch (err) { console.error("Failed to handle offer:", err); }
        } else if (payload.type === 'answer') {
            try {
                // Устанавливаем remote description только после того, как он был создан
                if (!peerConnection) {
                    statusEl.textContent = 'Ошибка: сначала создайте запрос на звонок.';
                    return;
                }
                await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.sdp));
                statusEl.textContent = 'Подключение...';
                connectionTimeout = setTimeout(() => { statusEl.textContent = 'Не удалось подключиться (тайм-аут).'; forceDisconnect(); }, 15000);
            } catch (err) { console.error("Failed to set remote description:", err); }
        }
    });
    
    // --- Data Channel Handlers ---
    function setupDataChannelHandlers() {
        dataChannel.onopen = async () => {
            statusEl.textContent = 'Канал открыт. Инициализация шифрования...';
            myIdentityKeys = await crypto.subtle.generateKey(ECDH_PARAMS, true, ['deriveKey', 'deriveBits']);
            const exportedPubKey = await crypto.subtle.exportKey('raw', myIdentityKeys.publicKey);
            dataChannel.send(JSON.stringify({
                type: 'crypto-handshake',
                key: Array.from(new Uint8Array(exportedPubKey))
            }));
        };
        dataChannel.binaryType = 'arraybuffer';
        dataChannel.onmessage = async (event) => {
            if (typeof event.data === 'string') {
                const msg = JSON.parse(event.data);
                if (msg.type === 'crypto-handshake') {
                    const pubKeyBuffer = new Uint8Array(msg.key);
                    peerIdentityKey = await crypto.subtle.importKey('raw', pubKeyBuffer, ECDH_PARAMS, true, []);
                    console.log("Peer public key received and imported.");
                    if (myIdentityKeys && peerIdentityKey) {
                        cryptoReady = true;
                        statusEl.textContent = 'Шифрование установлено. Канал защищен.';
                        await encryptAndSend({ type: 'nickname', value: nicknameInput.value || 'Anonymous' });
                    }
                }
            } else {
                await decryptAndProcess(event.data);
            }
        };
    }

    async function handleTextMessage(msg) {
        switch (msg.type) {
            case 'nickname': inCallInfoEl.textContent = `В звонке с: ${msg.value}`; break;
            case 'disconnect': forceDisconnect(); break;
            case 'chat': appendMessage(msg.value, 'peer-message'); break;
            case 'file-start':
                revokeDownloadLink();
                isTransferCancelled = false;
                incomingFileInfo = { name: msg.name, size: msg.size, checksum: msg.checksum };
                receivedSize = 0;
                transferStartTime = new Date().getTime();
                updateProgress(0);
                promptToAcceptFile(incomingFileInfo);
                break;
            case 'file-reject':
                fileTransferInfo.textContent = 'Получатель отклонил файл.';
                resetFileTransferUI(true);
                break;
            case 'file-accept':
                sendFileChunks();
                break;
            case 'file-cancel':
                isTransferCancelled = true;
                if (fileWriter) { await fileWriter.abort(); fileWriter = null; receivedFileHandle = null; }
                receiveBuffer = [];
                resetFileTransferUI();
                fileTransferInfo.textContent = 'Передача файла отменена собеседником.';
                break;
        }
    }

    async function handleBinaryMessage(data) {
        if (isTransferCancelled) return;
        receivedSize += data.byteLength;
        const progress = receivedSize / incomingFileInfo.size;
        updateProgress(progress);
        const elapsedTime = (new Date().getTime() - transferStartTime) / 1000;
        const speed = receivedSize / elapsedTime;
        fileTransferInfo.textContent = `Получение: ${formatBytes(receivedSize)} / ${formatBytes(incomingFileInfo.size)} (${formatSpeed(speed)})`;
        if (fileWriter) {
            await fileWriter.write(data);
        } else {
            receiveBuffer.push(data);
        }

        if (receivedSize === incomingFileInfo.size) {
            let finalFile;
            if (fileWriter) {
                await fileWriter.close();
                finalFile = await receivedFileHandle.getFile();
                fileWriter = null; receivedFileHandle = null;
            } else {
                finalFile = new Blob(receiveBuffer);
                receiveBuffer = [];
            }
            
            fileTransferInfo.textContent = `Проверка целостности файла: 0%`;
            await new Promise(resolve => setTimeout(resolve, 50));
            const checksum = await calculateChecksum(finalFile, (p) => { fileTransferInfo.textContent = `Проверка целостности файла: ${p.toFixed(0)}%`; });
            
            if (checksum === incomingFileInfo.checksum) {
                const link = document.createElement('a');
                currentDownloadUrl = URL.createObjectURL(finalFile);
                link.href = currentDownloadUrl;
                link.download = incomingFileInfo.name;
                link.textContent = `Скачать ${incomingFileInfo.name}`;
                link.onclick = () => setTimeout(revokeDownloadLink, 1000);
                fileTransferInfo.innerHTML = `Файл ${incomingFileInfo.name} получен и проверен. `;
                fileTransferInfo.appendChild(link);
            } else {
                fileTransferInfo.textContent = `ОШИБКА: Контрольная сумма файла не совпадает! Файл может быть поврежден.`;
            }
        }
    }
    
    // --- E2EE Crypto Functions ---
    async function encryptAndSend(payload, isBinary = false) {
        if (!cryptoReady) { console.error("Crypto not ready, cannot send message."); return; }
        const ephemeralKeys = await crypto.subtle.generateKey(ECDH_PARAMS, true, ['deriveBits']);
        const sharedSecret = await crypto.subtle.deriveBits(
            { name: 'ECDH', public: peerIdentityKey },
            ephemeralKeys.privateKey,
            256
        );
        const hkdfKey = await crypto.subtle.importKey('raw', sharedSecret, HKDF_PARAMS, false, ['deriveKey']);
        const aesKey = await crypto.subtle.deriveKey(
            { ...HKDF_PARAMS, salt: new Uint8Array(16), info: new Uint8Array() },
            hkdfKey,
            AES_PARAMS,
            true,
            ['encrypt']
        );
        const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
        let plaintext;
        if (isBinary) {
            plaintext = payload;
        } else {
            plaintext = new TextEncoder().encode(JSON.stringify(payload));
        }
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, plaintext);
        const exportedEphemeralPub = await crypto.subtle.exportKey('raw', ephemeralKeys.publicKey);
        const finalPacket = new Uint8Array(EPHEMERAL_KEY_LENGTH + IV_LENGTH + ciphertext.byteLength);
        finalPacket.set(new Uint8Array(exportedEphemeralPub), 0);
        finalPacket.set(iv, EPHEMERAL_KEY_LENGTH);
        finalPacket.set(new Uint8Array(ciphertext), EPHEMERAL_KEY_LENGTH + IV_LENGTH);
        dataChannel.send(finalPacket.buffer);
    }

    async function decryptAndProcess(packet) {
        try {
            const receivedEphemeralPubRaw = packet.slice(0, EPHEMERAL_KEY_LENGTH);
            const iv = packet.slice(EPHEMERAL_KEY_LENGTH, EPHEMERAL_KEY_LENGTH + IV_LENGTH);
            const ciphertext = packet.slice(EPHEMERAL_KEY_LENGTH + IV_LENGTH);
            const receivedEphemeralPub = await crypto.subtle.importKey('raw', receivedEphemeralPubRaw, ECDH_PARAMS, true, []);
            const sharedSecret = await crypto.subtle.deriveBits(
                { name: 'ECDH', public: receivedEphemeralPub },
                myIdentityKeys.privateKey,
                256
            );
            const hkdfKey = await crypto.subtle.importKey('raw', sharedSecret, HKDF_PARAMS, false, ['deriveKey']);
            const aesKey = await crypto.subtle.deriveKey(
                { ...HKDF_PARAMS, salt: new Uint8Array(16), info: new Uint8Array() },
                hkdfKey,
                AES_PARAMS,
                true,
                ['decrypt']
            );
            const decryptedPlaintextBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ciphertext);
            try {
                const payload = JSON.parse(new TextDecoder().decode(decryptedPlaintextBuffer));
                handleTextMessage(payload);
            } catch (e) {
                handleBinaryMessage(decryptedPlaintextBuffer);
            }
        } catch (error) {
            console.error("Decryption failed!", error);
            statusEl.textContent = "Ошибка расшифровки!";
        }
    }

    // --- Media and Audio ---
    async function setupLocalMedia() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: { noiseSuppression: true, echoCancellation: true } });
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(localStream);
            localGainNode = audioContext.createGain();
            const destination = audioContext.createMediaStreamDestination();
            source.connect(localGainNode).connect(destination);
            handleSendVolumeChange();
            // Добавляем трек в peerConnection
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        } catch (e) {
            statusEl.textContent = e.name === "NotAllowedError" ? 'Ошибка: Вы не разрешили доступ к микрофону.' : 'Ошибка: Не удалось инициализировать микрофон.';
            console.error("Error in setupLocalMedia:", e);
            throw e;
        }
    }

    function setupRemoteAudioProcessing(stream) {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (remoteStreamSource) remoteStreamSource.disconnect();
        remoteStreamSource = audioContext.createMediaStreamSource(stream);
        remoteGainNode = audioContext.createGain();
        remoteStreamSource.connect(remoteGainNode).connect(audioContext.destination);
        handleReceiveVolumeChange();
    }

    function handleSendVolumeChange() {
        if (localGainNode) localGainNode.gain.value = sendVolumeSlider.value / 100;
        sendVolumeValue.textContent = `${sendVolumeSlider.value}%`;
        localStorage.setItem('sendVolume', sendVolumeSlider.value);
    }
    function handleReceiveVolumeChange() {
        if (remoteGainNode) remoteGainNode.gain.value = receiveVolumeSlider.value / 100;
        receiveVolumeValue.textContent = `${receiveVolumeSlider.value}%`;
        localStorage.setItem('receiveVolume', receiveVolumeSlider.value);
    }

    sendVolumeSlider.addEventListener('input', handleSendVolumeChange);
    receiveVolumeSlider.addEventListener('input', handleReceiveVolumeChange);
    
    // --- Call Actions ---
    toggleMuteBtn.onclick = () => {
        if (!localStream) return;
        isMuted = !isMuted;
        localStream.getAudioTracks()[0].enabled = !isMuted;
        toggleMuteBtn.textContent = isMuted ? 'Включить микрофон' : 'Выключить микрофон';
        toggleMuteBtn.style.backgroundColor = isMuted ? 'var(--accent-orange)' : 'var(--accent-green)';
    };

    disconnectBtn.onclick = () => {
        encryptAndSend({ type: 'disconnect' }).finally(() => setTimeout(forceDisconnect, 200));
    };

    function forceDisconnect() {
        clearTimeout(connectionTimeout);
        if (localStream) localStream.getTracks().forEach(track => track.stop());
        if (peerConnection) peerConnection.close();
        if (audioContext && audioContext.state !== 'closed') { audioContext.close(); audioContext = null; }
        remoteAudio.srcObject = null;
        statusEl.textContent = 'Звонок завершен.';
        statusEl.style.color = 'var(--accent-orange)';
        connectionCardEl.hidden = false; inCallControlsEl.hidden = true;
        chatArea.innerHTML = ''; 
        resetFileTransferUI();
        revokeDownloadLink();
        cryptoReady = false; myIdentityKeys = null; peerIdentityKey = null;
    }

    // --- Chat Functions ---
    function appendMessage(msg, className) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${className}`;
        const content = document.createElement('div');
        content.className = 'message-content';
        content.textContent = msg;
        const meta = document.createElement('div');
        meta.className = 'message-meta';
        const time = new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        const timeSpan = document.createElement('span');
        timeSpan.textContent = time;
        const copyBtn = document.createElement('span');
        copyBtn.className = 'copy-btn';
        copyBtn.innerHTML = '&#x2398;'; copyBtn.title = 'Копировать';
        copyBtn.onclick = () => navigator.clipboard.writeText(msg).then(() => {
            copyBtn.innerHTML = '&#x2713;'; setTimeout(() => { copyBtn.innerHTML = '&#x2398;'; }, 1500);
        });
        meta.appendChild(timeSpan); meta.appendChild(copyBtn);
        bubble.appendChild(content); bubble.appendChild(meta);
        chatArea.appendChild(bubble);
        chatArea.scrollTop = chatArea.scrollHeight;
    }

    sendMsgBtn.onclick = () => {
        const msg = chatInput.value.trim();
        if (msg && dataChannel && dataChannel.readyState === 'open') {
            encryptAndSend({ type: 'chat', value: msg });
            appendMessage(msg, 'my-message');
            chatInput.value = '';
        }
    };
    chatInput.addEventListener('keypress', (e) => e.key === 'Enter' && sendMsgBtn.click());

    // --- File Transfer Functions ---
    let fileToSend;
    sendFileBtn.onclick = async () => {
        fileToSend = fileInput.files[0];
        if (!fileToSend) { fileTransferInfo.textContent = 'Сначала выберите файл.'; return; }
        
        isTransferCancelled = false;
        sendFileBtn.hidden = true; cancelFileTransferBtn.hidden = false; fileInput.disabled = true;
        fileTransferInfo.textContent = `Расчет хэша: 0%`;

        try {
            const checksum = await calculateChecksum(fileToSend, (p) => { fileTransferInfo.textContent = `Расчет хэша: ${p.toFixed(0)}%`; });
            if (isTransferCancelled) return;
            
            await encryptAndSend({ type: 'file-start', name: fileToSend.name, size: fileToSend.size, checksum });
            fileTransferInfo.textContent = 'Ожидание подтверждения от получателя...';
        } catch (error) {
            if (error.message === 'Cancelled') { resetFileTransferUI(true); fileTransferInfo.textContent = 'Расчет хэша отменен.'; }
            else { console.error("Ошибка при расчете хэша:", error); fileTransferInfo.textContent = "Ошибка при расчете хэша."; resetFileTransferUI(true); }
        }
    };

    function sendFileChunks() {
        let offset = 0;
        transferStartTime = new Date().getTime();
        const sendChunk = () => {
            if (isTransferCancelled || offset >= fileToSend.size) {
                if(!isTransferCancelled) fileTransferInfo.textContent = `Файл ${fileToSend.name} отправлен.`;
                resetFileTransferUI(true);
                return;
            }
            if (dataChannel.bufferedAmount > 1024 * 1024) { setTimeout(sendChunk, 100); return; }
            
            const slice = fileToSend.slice(offset, offset + CHUNK_SIZE);
            const reader = new FileReader();
            reader.onload = async e => {
                if (dataChannel.readyState !== 'open' || isTransferCancelled) { resetFileTransferUI(true); return; }
                try {
                    await encryptAndSend(e.target.result, true);
                    offset += e.target.result.byteLength;
                    updateProgress(offset / fileToSend.size);
                    const elapsedTime = (new Date().getTime() - transferStartTime) / 1000;
                    const speed = offset / elapsedTime;
                    fileTransferInfo.textContent = `Отправка: ${formatBytes(offset)} / ${formatBytes(fileToSend.size)} (${formatSpeed(speed)})`;
                    sendChunk();
                } catch (error) {
                    console.error("Ошибка при отправке чанка:", error);
                    fileTransferInfo.textContent = "Ошибка при отправке файла."; resetFileTransferUI(true);
                }
            };
            reader.readAsArrayBuffer(slice);
        };
        sendChunk();
    }

    function promptToAcceptFile(fileMeta) {
        fileTransferInfo.innerHTML = `Входящий файл: <strong>${fileMeta.name}</strong> (${formatBytes(fileMeta.size)}) <br>`;
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'action-buttons'; buttonContainer.style.display = 'flex'; buttonContainer.style.gap = '10px';
        const acceptBtn = document.createElement('button');
        acceptBtn.textContent = 'Принять';
        acceptBtn.onclick = async () => {
            if ('showSaveFilePicker' in window) {
                try {
                    receivedFileHandle = await window.showSaveFilePicker({ suggestedName: fileMeta.name });
                    fileWriter = await receivedFileHandle.createWritable();
                    await encryptAndSend({ type: 'file-accept' });
                    fileTransferInfo.textContent = `Получение файла: ${fileMeta.name}...`;
                } catch (err) {
                    if (err.name === 'AbortError') {
                        await encryptAndSend({ type: 'file-reject' });
                        fileTransferInfo.textContent = 'Вы отменили прием файла.';
                    } else { console.error("Ошибка showSaveFilePicker:", err); fileTransferInfo.textContent = 'Ошибка: не удалось открыть окно сохранения.'; }
                }
            } else {
                receiveBuffer = [];
                await encryptAndSend({ type: 'file-accept' });
                fileTransferInfo.textContent = `Получение файла (в RAM): ${fileMeta.name}...`;
            }
        };
        const rejectBtn = document.createElement('button');
        rejectBtn.textContent = 'Отклонить'; rejectBtn.style.backgroundColor = 'var(--accent-orange)';
        rejectBtn.onclick = async () => {
            await encryptAndSend({ type: 'file-reject' });
            fileTransferInfo.textContent = 'Вы отклонили файл.';
        };
        buttonContainer.appendChild(acceptBtn); buttonContainer.appendChild(rejectBtn); fileTransferInfo.appendChild(buttonContainer);
    }
    
    cancelFileTransferBtn.onclick = () => {
        isTransferCancelled = true;
        if (dataChannel && dataChannel.readyState === 'open' && cryptoReady) {
            encryptAndSend({ type: 'file-cancel' });
        }
        resetFileTransferUI(true);
        fileTransferInfo.textContent = 'Передача файла отменена.';
    };

    function resetFileTransferUI(isSender = false) {
        updateProgress(0);
        if (isSender || !fileTransferInfo.innerHTML.includes('<a href')) { fileTransferInfo.textContent = ''; }
        sendFileBtn.hidden = false; cancelFileTransferBtn.hidden = true;
        fileInput.disabled = false; fileInput.value = ''; fileToSend = null;
    }

    function updateProgress(progress) {
        const percent = Math.round(progress * 100);
        progressBar.style.width = `${percent}%`;
        progressBar.textContent = `${percent}%`;
    }

    async function calculateChecksum(fileOrBlob, onProgress = () => {}) {
        return new Promise((resolve, reject) => {
            const hash = sha256.create();
            const reader = fileOrBlob.stream().getReader();
            let bytesRead = 0; const totalBytes = fileOrBlob.size;
            function processChunk() {
                if (isTransferCancelled) { reject(new Error('Cancelled')); return; }
                reader.read().then(({ done, value }) => {
                    if (done) { onProgress(100); resolve(hash.hex()); return; }
                    bytesRead += value.length;
                    hash.update(value);
                    onProgress((bytesRead / totalBytes) * 100);
                    setTimeout(processChunk, 0); 
                }).catch(reject);
            }
            processChunk();
        });
    }
    
    function revokeDownloadLink() {
        if (currentDownloadUrl) {
            URL.revokeObjectURL(currentDownloadUrl);
            currentDownloadUrl = null;
            console.log("Ссылка на скачанный файл и связанная память очищены.");
        }
    }

    // --- Utility Functions ---
    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    function formatSpeed(bytesPerSecond) { return formatBytes(bytesPerSecond) + '/s'; }
</script>
</body>
</html>



