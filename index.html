<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure P2P Voice Chat with File Integrity</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #4ec9b0;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .section {
            background-color: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .section h2 {
            color: #569cd6;
            font-size: 16px;
            margin-bottom: 15px;
        }

        button {
            background-color: #0e639c;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 5px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #1177bb;
        }

        button:disabled {
            background-color: #3e3e42;
            cursor: not-allowed;
        }

        button.danger {
            background-color: #c72e0f;
        }

        button.danger:hover {
            background-color: #e03e0f;
        }

        button.success {
            background-color: #0e7a0d;
        }

        button.success:hover {
            background-color: #16a014;
        }

        textarea {
            width: 100%;
            background-color: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 2px;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 10px;
        }

        input[type="text"] {
            width: 100%;
            background-color: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 2px;
            padding: 8px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        input[type="file"] {
            margin-bottom: 10px;
        }

        .status {
            padding: 10px;
            border-radius: 2px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .status.info {
            background-color: #1a3a52;
            border-left: 3px solid #569cd6;
        }

        .status.success {
            background-color: #1a3a1a;
            border-left: 3px solid #4ec9b0;
        }

        .status.error {
            background-color: #3a1a1a;
            border-left: 3px solid #f48771;
        }

        .status.warning {
            background-color: #3a3a1a;
            border-left: 3px solid #dcdcaa;
        }

        .chat-messages {
            height: 300px;
            overflow-y: auto;
            background-color: #1e1e1e;
            border: 1px solid #3e3e42;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 2px;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 2px;
        }

        .message.sent {
            background-color: #1a3a52;
            text-align: right;
        }

        .message.received {
            background-color: #2d2d30;
        }

        .message .time {
            font-size: 11px;
            color: #858585;
            margin-bottom: 3px;
        }

        .file-transfer {
            padding: 10px;
            background-color: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 2px;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .file-transfer.pending {
            border-left: 3px solid #dcdcaa;
        }

        .file-transfer.success {
            border-left: 3px solid #4ec9b0;
        }

        .file-transfer.error {
            border-left: 3px solid #f48771;
        }

        .file-hash {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            color: #858585;
            margin-top: 5px;
            word-break: break-all;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .copy-btn {
            background-color: #0e7a0d;
        }

        .copy-btn:hover {
            background-color: #16a014;
        }

        .debug-console {
            background-color: #1e1e1e;
            border: 1px solid #3e3e42;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            max-height: 100px;
            overflow-y: auto;
        }

        .debug-log {
            color: #858585;
            margin-bottom: 2px;
        }

        .security-info {
            background-color: #1a3a52;
            padding: 10px;
            border-radius: 2px;
            font-size: 12px;
            margin-top: 10px;
        }

        .security-info p {
            margin-bottom: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #3e3e42;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background-color: #4ec9b0;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Secure P2P Voice Chat (End-to-End Encrypted)</h1>

        <div class="grid">
            <div>
                <div class="section">
                    <h2>1. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ</h2>
                    <button id="startBtn" class="success">–ù–∞—á–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</button>
                    <button id="stopBtn" class="danger" disabled>–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
                    <div id="connectionStatus" class="status info" style="margin-top: 10px;">
                        –ì–æ—Ç–æ–≤ –∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—é
                    </div>
                </div>

                <div class="section">
                    <h2>2. –û–±–º–µ–Ω –¥–∞–Ω–Ω—ã–º–∏</h2>
                    <div style="margin-bottom: 10px;">
                        <strong>–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ (–æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É):</strong>
                        <textarea id="offerText" rows="4" readonly></textarea>
                        <button id="copyOfferBtn" class="copy-btn" disabled>üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</button>
                    </div>
                    <div>
                        <strong>–û—Ç–≤–µ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ (–≤—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞):</strong>
                        <textarea id="answerText" rows="4" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –æ—Ç–≤–µ—Ç –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞..."></textarea>
                        <button id="connectBtn" disabled>üîó –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</button>
                    </div>
                </div>
            </div>

            <div>
                <div class="section">
                    <h2>üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
                    <div id="encryptionStatus" class="status info">
                        –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ
                    </div>
                    <div class="security-info">
                        <p>‚úì RSA-OAEP 2048 –±–∏—Ç –¥–ª—è –æ–±–º–µ–Ω–∞ –∫–ª—é—á–∞–º–∏</p>
                        <p>‚úì AES-GCM 256 –±–∏—Ç –¥–ª—è –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö</p>
                        <p>‚úì MD5 –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Ñ–∞–π–ª–æ–≤</p>
                        <p>‚úì –®—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ: –í–∫–ª—é—á–µ–Ω–æ</p>
                        <p>‚úì –ö–∞—á–µ—Å—Ç–≤–æ: 510 –∫–±–∏—Ç/—Å (Opus)</p>
                        <p>‚ö†Ô∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã —Å–∫–≤–æ–∑–Ω—ã–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º</p>
                    </div>
                </div>

                <div class="section">
                    <h2>üéôÔ∏è –ê—É–¥–∏–æ –∫–æ–Ω—Ç—Ä–æ–ª—å</h2>
                    <button id="muteBtn" disabled>üé§ –í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
                    <button id="volumeBtn" disabled>üîä –ì—Ä–æ–º–∫–æ—Å—Ç—å: 100%</button>
                    <audio id="remoteAudio" autoplay></audio>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="section">
                <h2>üí¨ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —á–∞—Ç</h2>
                <div id="chatMessages" class="chat-messages"></div>
                <input type="text" id="messageInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–∑–∞—à–∏—Ñ—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)..." disabled>
                <button id="sendMessageBtn" disabled>üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
                <div class="debug-console" id="debugConsole"></div>
            </div>

            <div class="section">
                <h2>üìÅ –ü–µ—Ä–µ–¥–∞—á–∞ —Ñ–∞–π–ª–æ–≤ (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏)</h2>
                <input type="file" id="fileInput" disabled>
                <button id="sendFileBtn" disabled>üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª</button>
                <div id="fileTransfers"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï =====
        let peerConnection = null;
        let dataChannel = null;
        let localStream = null;
        let publicKey = null;
        let privateKey = null;
        let remotePublicKey = null;
        let symmetricKey = null;
        let isMuted = false;
        let volumeLevel = 1.0;
        let isInitiator = false;
        let keyExchangeComplete = false;

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const offerText = document.getElementById('offerText');
        const answerText = document.getElementById('answerText');
        const copyOfferBtn = document.getElementById('copyOfferBtn');
        const connectBtn = document.getElementById('connectBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const encryptionStatus = document.getElementById('encryptionStatus');
        const remoteAudio = document.getElementById('remoteAudio');
        const muteBtn = document.getElementById('muteBtn');
        const volumeBtn = document.getElementById('volumeBtn');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const fileInput = document.getElementById('fileInput');
        const sendFileBtn = document.getElementById('sendFileBtn');
        const fileTransfers = document.getElementById('fileTransfers');
        const debugConsole = document.getElementById('debugConsole');

        // –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤
        let fileReceivers = {};

        // ===== –õ–û–ì–ò–†–û–í–ê–ù–ò–ï =====
        function log(message) {
            console.log(message);
            const logEntry = document.createElement('div');
            logEntry.className = 'debug-log';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugConsole.appendChild(logEntry);
            debugConsole.scrollTop = debugConsole.scrollHeight;
            if (debugConsole.children.length > 30) {
                debugConsole.removeChild(debugConsole.firstChild);
            }
        }

        // ===== MD5 –•–ï–®–ò–†–û–í–ê–ù–ò–ï =====
        function calculateMD5(data) {
            return CryptoJS.MD5(data).toString();
        }

        function calculateMD5FromArrayBuffer(buffer) {
            const wordArray = CryptoJS.lib.WordArray.create(buffer);
            return CryptoJS.MD5(wordArray).toString();
        }

        // ===== –†–ê–ë–û–¢–ê –° –ë–£–§–ï–†–û–ú =====
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            const chunkSize = 8192;
            let binary = '';
            
            for (let i = 0; i < bytes.length; i += chunkSize) {
                const chunk = bytes.subarray(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
            }
            
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // ===== –ö–†–ò–ü–¢–û–ì–†–ê–§–ò–Ø =====
        const rtcConfig = {
            iceServers: []
        };

        async function generateKeyPair() {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: "SHA-256"
                },
                true,
                ["encrypt", "decrypt"]
            );
            return keyPair;
        }

        async function exportPublicKey(key) {
            const exported = await window.crypto.subtle.exportKey("spki", key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function importPublicKey(keyData) {
            const binaryKey = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
            return await window.crypto.subtle.importKey(
                "spki",
                binaryKey,
                {
                    name: "RSA-OAEP",
                    hash: "SHA-256"
                },
                true,
                ["encrypt"]
            );
        }

        async function generateSymmetricKey() {
            return await window.crypto.subtle.generateKey(
                {
                    name: "AES-GCM",
                    length: 256
                },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(data, key) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            let encoded;
            
            if (typeof data === 'string') {
                encoded = new TextEncoder().encode(data);
            } else {
                encoded = data;
            }
            
            const encrypted = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                encoded
            );
            
            return {
                iv: btoa(String.fromCharCode(...iv)),
                data: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
            };
        }

        async function decryptData(encryptedObj, key) {
            try {
                const iv = Uint8Array.from(atob(encryptedObj.iv), c => c.charCodeAt(0));
                const data = Uint8Array.from(atob(encryptedObj.data), c => c.charCodeAt(0));
                
                const decrypted = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    key,
                    data
                );
                return new TextDecoder().decode(decrypted);
            } catch (error) {
                log('‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏: ' + error.message);
                throw error;
            }
        }

        async function encryptSymmetricKey(symmetricKey, publicKey) {
            const exported = await window.crypto.subtle.exportKey("raw", symmetricKey);
            const encrypted = await window.crypto.subtle.encrypt(
                {
                    name: "RSA-OAEP"
                },
                publicKey,
                exported
            );
            return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        }

        async function decryptSymmetricKey(encryptedKey, privateKey) {
            const encrypted = Uint8Array.from(atob(encryptedKey), c => c.charCodeAt(0));
            const decrypted = await window.crypto.subtle.decrypt(
                {
                    name: "RSA-OAEP"
                },
                privateKey,
                encrypted
            );
            return await window.crypto.subtle.importKey(
                "raw",
                decrypted,
                {
                    name: "AES-GCM",
                    length: 256
                },
                true,
                ["encrypt", "decrypt"]
            );
        }

        // ===== –û–ë–ù–û–í–õ–ï–ù–ò–ï –°–¢–ê–¢–£–°–ê =====
        function updateStatus(message, type = 'info') {
            connectionStatus.textContent = message;
            connectionStatus.className = `status ${type}`;
            log(message);
        }

        function updateEncryptionStatus(message, type = 'info') {
            encryptionStatus.textContent = message;
            encryptionStatus.className = `status ${type}`;
        }

        // ===== DATA CHANNEL –£–ü–†–ê–í–õ–ï–ù–ò–ï =====
        function setupDataChannel(channel) {
            channel.binaryType = 'arraybuffer';
            
            channel.onopen = async () => {
                log('‚úÖ Data channel –æ—Ç–∫—Ä—ã—Ç!');
                updateStatus('–ö–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö –æ—Ç–∫—Ä—ã—Ç', 'success');
                
                if (keyExchangeComplete) {
                    enableChatAndFiles();
                    log('üí¨ –ß–∞—Ç –∏ —Ñ–∞–π–ª—ã —É–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã');
                } else if (isInitiator) {
                    log('üîê –û—Ç–ø—Ä–∞–≤–ª—è—é —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á...');
                    await sendSymmetricKey(channel);
                } else {
                    log('‚è≥ –ñ–¥—É –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞...');
                }
            };

            channel.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'key') {
                        log('üîë –ü–æ–ª—É—á–∞—é —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á...');
                        symmetricKey = await decryptSymmetricKey(message.key, privateKey);
                        keyExchangeComplete = true;
                        updateEncryptionStatus('üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ (RSA-OAEP + AES-GCM 256)', 'success');
                        log('‚úÖ –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω –∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
                        enableChatAndFiles();
                        
                        if (!isInitiator) {
                            log('üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–ª—é—á–∞...');
                            await sendSymmetricKey(channel);
                        }
                    } else if (message.type === 'file_info') {
                        const fileInfo = JSON.parse(await decryptData(message.data, symmetricKey));
                        log(`üìã –ù–∞—á–∞–ª–æ –ø–æ–ª—É—á–µ–Ω–∏—è: ${fileInfo.name} (${fileInfo.totalChunks} chunks)`);
                        if (!fileReceivers[fileInfo.fileId]) {
                            fileReceivers[fileInfo.fileId] = {
                                chunks: new Array(fileInfo.totalChunks),
                                received: 0,
                                name: fileInfo.name,
                                size: fileInfo.size,
                                startTime: Date.now(),
                                expectedMD5: fileInfo.md5,
                                mimeType: fileInfo.mimeType
                            };
                            addFileTransferUI(fileInfo.fileId, fileInfo.name, fileInfo.size, 'pending');
                        }
                    } else if (message.type === 'file_chunk' && keyExchangeComplete) {
                        await receiveFileChunk(message);
                    } else if (message.type === 'file_complete') {
                        const fileComplete = JSON.parse(await decryptData(message.data, symmetricKey));
                        if (fileReceivers[fileComplete.fileId]) {
                            await assembleAndVerifyFile(fileComplete.fileId);
                        }
                    } else if (message.type === 'chat' && keyExchangeComplete) {
                        const decrypted = await decryptData(message.data, symmetricKey);
                        displayMessage(decrypted, 'received');
                    }
                } catch (error) {
                    log('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ' + error.message);
                    console.error(error);
                }
            };

            channel.onerror = (error) => {
                log('‚ùå Data channel –æ—à–∏–±–∫–∞: ' + error.message);
                console.error(error);
            };

            channel.onclose = () => {
                log('‚ö†Ô∏è Data channel –∑–∞–∫—Ä—ã—Ç');
                updateStatus('–ö–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫—Ä—ã—Ç', 'error');
                messageInput.disabled = true;
                sendMessageBtn.disabled = true;
                fileInput.disabled = true;
                sendFileBtn.disabled = true;
            };
        }

        async function sendSymmetricKey(channel) {
            try {
                if (!symmetricKey) {
                    log('üîë –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á AES-GCM...');
                    symmetricKey = await generateSymmetricKey();
                }
                
                if (!remotePublicKey) {
                    log('‚ùå –ù–µ—Ç –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
                    return;
                }
                
                const encryptedKey = await encryptSymmetricKey(symmetricKey, remotePublicKey);
                channel.send(JSON.stringify({
                    type: 'key',
                    key: encryptedKey
                }));
                log('‚úÖ –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω RSA-OAEP –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');
                keyExchangeComplete = true;
                updateEncryptionStatus('üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ (RSA-OAEP + AES-GCM 256)', 'success');
            } catch (error) {
                log('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–ª—é—á–∞: ' + error.message);
            }
        }

        function enableChatAndFiles() {
            messageInput.disabled = false;
            sendMessageBtn.disabled = false;
            fileInput.disabled = false;
            sendFileBtn.disabled = false;
            log('‚úÖ –ß–∞—Ç –∏ –ø–µ—Ä–µ–¥–∞—á–∞ —Ñ–∞–π–ª–æ–≤ –¥–æ—Å—Ç—É–ø–Ω—ã');
        }

        // ===== –°–û–ï–î–ò–ù–ï–ù–ò–ï WEBRTC =====
        async function startConnection() {
            try {
                isInitiator = true;
                updateStatus('üîê –ì–µ–Ω–µ—Ä–∞—Ü–∏—è RSA –∫–ª—é—á–µ–π...', 'info');
                log('üöÄ –°—Ç–∞—Ä—Ç—É—é –∫–∞–∫ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...');
                
                const keyPair = await generateKeyPair();
                publicKey = keyPair.publicKey;
                privateKey = keyPair.privateKey;
                log('‚úÖ RSA-OAEP 2048 –∫–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
                
                updateEncryptionStatus('üîë –ö–ª—é—á–∏ –≥–æ—Ç–æ–≤—ã (–æ–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è)', 'info');

                updateStatus('üé§ –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...', 'info');
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000,
                        channelCount: 2
                    },
                    video: false
                });
                log('‚úÖ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (—à—É–º–æ–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ)');

                peerConnection = new RTCPeerConnection(rtcConfig);

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                const transceivers = peerConnection.getTransceivers();
                transceivers.forEach(transceiver => {
                    if (transceiver.sender && transceiver.sender.track && transceiver.sender.track.kind === 'audio') {
                        const parameters = transceiver.sender.getParameters();
                        if (!parameters.encodings) {
                            parameters.encodings = [{}];
                        }
                        parameters.encodings[0].maxBitrate = 510000;
                        transceiver.sender.setParameters(parameters);
                    }
                });
                log('üîä Opus –∫–æ–¥–µ–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –Ω–∞ 510 –∫–±–∏—Ç/—Å');

                dataChannel = peerConnection.createDataChannel('secureChannel', {
                    ordered: true
                });
                setupDataChannel(dataChannel);

                let iceCandidates = [];
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        iceCandidates.push(event.candidate);
                    }
                };

                peerConnection.onicegatheringstatechange = async () => {
                    if (peerConnection.iceGatheringState === 'complete') {
                        log('‚úÖ –í—Å–µ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–±—Ä–∞–Ω—ã (' + iceCandidates.length + ')');
                        const publicKeyStr = await exportPublicKey(publicKey);
                        const offer = {
                            sdp: peerConnection.localDescription,
                            publicKey: publicKeyStr,
                            candidates: iceCandidates
                        };
                        
                        const offerJson = JSON.stringify(offer);
                        const offerBase64 = btoa(unescape(encodeURIComponent(offerJson)));
                        offerText.value = offerBase64;
                        copyOfferBtn.disabled = false;
                        connectBtn.disabled = false;
                        updateStatus('‚úÖ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É!', 'success');
                    }
                };

                peerConnection.ontrack = (event) => {
                    log('üîä –í—Ö–æ–¥—è—â–∏–π –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω');
                    remoteAudio.srcObject = event.streams[0];
                    updateStatus('üéôÔ∏è –ê—É–¥–∏–æ–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω', 'success');
                };

                peerConnection.ondatachannel = (event) => {
                    log('üì° –í—Ö–æ–¥—è—â–∏–π data channel –ø–æ–ª—É—á–µ–Ω');
                    dataChannel = event.channel;
                    setupDataChannel(dataChannel);
                };

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('üìù Offer —Å–æ–∑–¥–∞–Ω –∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∫–∞–∫ local description');

                updateStatus('‚è≥ –°–±–æ—Ä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...', 'info');

                startBtn.disabled = true;
                stopBtn.disabled = false;
                muteBtn.disabled = false;
                volumeBtn.disabled = false;

            } catch (error) {
                updateStatus('‚ùå –û—à–∏–±–∫–∞: ' + error.message, 'error');
                log('‚ùå –û—à–∏–±–∫–∞ –Ω–∞—á–∞–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ' + error.message);
                console.error(error);
            }
        }

        async function connectWithAnswer() {
            try {
                const answerBase64 = answerText.value.trim();
                if (!answerBase64) {
                    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—Å—Ç–∞–≤—å—Ç–µ –æ—Ç–≤–µ—Ç –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞');
                    return;
                }

                log('üîó –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –æ—Ç–≤–µ—Ç–æ–º...');

                const answerJson = decodeURIComponent(escape(atob(answerBase64)));
                const answer = JSON.parse(answerJson);

                remotePublicKey = await importPublicKey(answer.publicKey);
                log('‚úÖ –ü—É–±–ª–∏—á–Ω—ã–π RSA –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω');
                updateEncryptionStatus('üîë –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω', 'info');

                await peerConnection.setRemoteDescription(answer.sdp);
                log('üìù Remote description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');

                for (const candidate of answer.candidates) {
                    await peerConnection.addIceCandidate(candidate);
                }
                log('‚úÖ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã (' + answer.candidates.length + ')');

                if (dataChannel && dataChannel.readyState === 'open') {
                    log('üì§ Data channel –æ—Ç–∫—Ä—ã—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è—é —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–π –∫–ª—é—á...');
                    await sendSymmetricKey(dataChannel);
                } else {
                    log('‚è≥ –ñ–¥—É –æ—Ç–∫—Ä—ã—Ç–∏—è data channel –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –∫–ª—é—á–∞...');
                }

                updateStatus('‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!', 'success');
                connectBtn.disabled = true;
                answerText.disabled = true;

            } catch (error) {
                updateStatus('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message, 'error');
                log('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                console.error(error);
            }
        }

        function copyOffer() {
            offerText.select();
            document.execCommand('copy');
            updateStatus('üìã –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!', 'success');
            log('‚úÖ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ');
        }

        function stopConnection() {
            log('üõë –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ...');
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            remoteAudio.srcObject = null;
            offerText.value = '';
            answerText.value = '';
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            copyOfferBtn.disabled = true;
            connectBtn.disabled = true;
            muteBtn.disabled = true;
            volumeBtn.disabled = true;
            messageInput.disabled = true;
            sendMessageBtn.disabled = true;
            fileInput.disabled = true;
            sendFileBtn.disabled = true;
            answerText.disabled = false;

            publicKey = null;
            privateKey = null;
            remotePublicKey = null;
            symmetricKey = null;
            keyExchangeComplete = false;
            isInitiator = false;

            updateStatus('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'info');
            updateEncryptionStatus('‚ùå –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ', 'info');
            log('‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
        }

        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                isMuted = !isMuted;
                audioTrack.enabled = !isMuted;
                muteBtn.textContent = isMuted ? 'üî¥ –í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : 'üé§ –í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
                log(isMuted ? 'üî¥ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω' : 'üé§ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω');
            }
        }

        function toggleVolume() {
            volumeLevel = volumeLevel === 1.0 ? 0.5 : (volumeLevel === 0.5 ? 0.0 : 1.0);
            remoteAudio.volume = volumeLevel;
            volumeBtn.textContent = `üîä –ì—Ä–æ–º–∫–æ—Å—Ç—å: ${Math.round(volumeLevel * 100)}%`;
            log('üîä –ì—Ä–æ–º–∫–æ—Å—Ç—å: ' + Math.round(volumeLevel * 100) + '%');
        }

        // ===== –ß–ê–¢ =====
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            if (!dataChannel || dataChannel.readyState !== 'open') {
                log('‚ùå Data channel –Ω–µ –æ—Ç–∫—Ä—ã—Ç');
                return;
            }
            
            if (!keyExchangeComplete || !symmetricKey) {
                log('‚ùå –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –µ—â–µ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ');
                return;
            }

            try {
                const encrypted = await encryptData(message, symmetricKey);
                const msgData = JSON.stringify({
                    type: 'chat',
                    data: encrypted
                });
                
                dataChannel.send(msgData);
                log('‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ' + message.substring(0, 30) + '...');
                displayMessage(message, 'sent');
                messageInput.value = '';
            } catch (error) {
                log('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ' + error.message);
                console.error(error);
            }
        }

        function displayMessage(text, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'time';
            timeDiv.textContent = new Date().toLocaleTimeString();
            
            const textDiv = document.createElement('div');
            textDiv.textContent = text;
            
            messageDiv.appendChild(timeDiv);
            messageDiv.appendChild(textDiv);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // ===== –ü–ï–†–ï–î–ê–ß–ê –§–ê–ô–õ–û–í =====
        async function sendFile() {
            const file = fileInput.files[0];
            if (!file) return;

            if (!dataChannel || dataChannel.readyState !== 'open') {
                log('‚ùå Data channel –Ω–µ –æ—Ç–∫—Ä—ã—Ç');
                return;
            }
            
            if (!keyExchangeComplete || !symmetricKey) {
                log('‚ùå –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –µ—â–µ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ');
                return;
            }

            log(`üì§ –ù–∞—á–∏–Ω–∞—é –æ—Ç–ø—Ä–∞–≤–∫—É —Ñ–∞–π–ª–∞: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`);
            sendFileBtn.disabled = true;

            const fileId = Math.random().toString(36).substring(7);
            const chunkSize = 16000;
            const totalChunks = Math.ceil(file.size / chunkSize);

            const reader = new FileReader();
            
            reader.onload = async (e) => {
                try {
                    const fullData = new Uint8Array(e.target.result);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º MD5 –≤—Å–µ–≥–æ —Ñ–∞–π–ª–∞
                    const fileMD5 = calculateMD5FromArrayBuffer(fullData);
                    log(`üîê MD5 —Ñ–∞–π–ª–∞ –≤—ã—á–∏—Å–ª–µ–Ω: ${fileMD5}`);
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
                    const fileInfoEncrypted = await encryptData(
                        JSON.stringify({
                            type: 'file_start',
                            name: file.name,
                            size: file.size,
                            mimeType: file.type,
                            totalChunks: totalChunks,
                            fileId: fileId,
                            md5: fileMD5
                        }),
                        symmetricKey
                    );
                    
                    dataChannel.send(JSON.stringify({
                        type: 'file_info',
                        data: fileInfoEncrypted
                    }));
                    
                    log(`üìã –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–∞ AES-GCM, MD5: ${fileMD5.substring(0, 8)}...)`);
                    addFileTransferUI(fileId, file.name, file.size, 'pending');
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º chunks
                    let sentChunks = 0;
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * chunkSize;
                        const end = Math.min(start + chunkSize, file.size);
                        const chunkData = fullData.slice(start, end);
                        
                        const chunkBase64 = arrayBufferToBase64(chunkData);
                        const encrypted = await encryptData(chunkBase64, symmetricKey);
                        
                        dataChannel.send(JSON.stringify({
                            type: 'file_chunk',
                            fileId: fileId,
                            chunkIndex: i,
                            totalChunks: totalChunks,
                            data: encrypted
                        }));
                        
                        sentChunks++;
                        const progress = Math.round((sentChunks / totalChunks) * 100);
                        
                        if (i % 10 === 0 || i === totalChunks - 1) {
                            log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞: ${progress}% (${sentChunks}/${totalChunks} chunks)`);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 5));
                    }
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
                    const finishEncrypted = await encryptData(
                        JSON.stringify({
                            type: 'file_finish',
                            fileId: fileId
                        }),
                        symmetricKey
                    );
                    
                    dataChannel.send(JSON.stringify({
                        type: 'file_complete',
                        data: finishEncrypted
                    }));
                    
                    log(`‚úÖ –§–∞–π–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω AES-GCM, –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏: MD5)`);
                    fileInput.value = '';
                    
                } catch (error) {
                    log('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                    console.error(error);
                } finally {
                    sendFileBtn.disabled = false;
                }
            };
            
            reader.onerror = () => {
                log('‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞');
                sendFileBtn.disabled = false;
            };
            
            reader.readAsArrayBuffer(file);
        }

        async function receiveFileChunk(message) {
            try {
                const data = message.data;
                const fileId = message.fileId;
                const chunkIndex = message.chunkIndex;
                const totalChunks = message.totalChunks;
                
                if (!fileReceivers[fileId]) {
                    fileReceivers[fileId] = {
                        chunks: new Array(totalChunks),
                        received: 0,
                        startTime: Date.now()
                    };
                }
                
                const decrypted = await decryptData(data, symmetricKey);
                fileReceivers[fileId].chunks[chunkIndex] = decrypted;
                fileReceivers[fileId].received++;
                
                const progress = Math.round((fileReceivers[fileId].received / totalChunks) * 100);
                
                if (chunkIndex % 10 === 0 || progress === 100) {
                    log(`üì• –ü–æ–ª—É—á–µ–Ω–∏–µ: ${progress}% (${fileReceivers[fileId].received}/${totalChunks})`);
                }
                
            } catch (error) {
                log('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è chunk: ' + error.message);
                console.error(error);
            }
        }

        async function assembleAndVerifyFile(fileId) {
            try {
                const receiver = fileReceivers[fileId];
                log(`üîß –°–æ–±–∏—Ä–∞—é —Ñ–∞–π–ª: ${receiver.name}...`);
                
                let binary = '';
                for (let i = 0; i < receiver.chunks.length; i++) {
                    const chunkBinary = atob(receiver.chunks[i]);
                    binary += chunkBinary;
                }
                
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                
                // –í—ã—á–∏—Å–ª—è–µ–º MD5 –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
                const calculatedMD5 = calculateMD5FromArrayBuffer(bytes.buffer);
                log(`üîê MD5 –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: ${calculatedMD5}`);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                if (calculatedMD5 !== receiver.expectedMD5) {
                    log(`‚ùå –û–®–ò–ë–ö–ê –¶–ï–õ–û–°–¢–ù–û–°–¢–ò! –û–∂–∏–¥–∞–ª–æ—Å—å: ${receiver.expectedMD5}, –ø–æ–ª—É—á–µ–Ω–æ: ${calculatedMD5}`);
                    updateFileTransferUI(fileId, 'error', `–û—à–∏–±–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏! MD5 –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç`);
                    delete fileReceivers[fileId];
                    return;
                }
                
                log(`‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ–π–¥–µ–Ω–∞! MD5 —Å–æ–≤–ø–∞–¥–∞–µ—Ç`);
                
                // –§–∞–π–ª —Ü–µ–ª–æ—Å—Ç–µ–Ω, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ
                const blob = new Blob([bytes], { type: receiver.mimeType || 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = receiver.name;
                a.click();
                
                const elapsed = ((Date.now() - receiver.startTime) / 1000).toFixed(2);
                const speed = (receiver.size / 1024 / elapsed).toFixed(2);
                
                log(`‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω (${(receiver.size / 1024).toFixed(2)} KB –∑–∞ ${elapsed}s, ${speed} KB/s)`);
                log(`üîê –§–∞–π–ª –±—ã–ª –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω: RSA-OAEP (–æ–±–º–µ–Ω –∫–ª—é—á–∞–º–∏) + AES-GCM 256 (–¥–∞–Ω–Ω—ã–µ)`);
                log(`‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏: MD5`);
                
                updateFileTransferUI(fileId, 'success', `‚úÖ MD5: ${calculatedMD5.substring(0, 16)}...`);
                delete fileReceivers[fileId];
                
            } catch (error) {
                log('‚ùå –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∫–∏/–ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                console.error(error);
                updateFileTransferUI(fileId, 'error', error.message);
            }
        }

        function addFileTransferUI(fileId, name, size, status) {
            const transferDiv = document.createElement('div');
            transferDiv.id = `file-${fileId}`;
            transferDiv.className = `file-transfer ${status}`;
            
            const nameDiv = document.createElement('div');
            nameDiv.textContent = `üì¶ ${name} (${(size / 1024).toFixed(2)} KB)`;
            
            const progressDiv = document.createElement('div');
            progressDiv.className = 'progress-bar';
            const progressFill = document.createElement('div');
            progressFill.className = 'progress-fill';
            progressDiv.appendChild(progressFill);
            
            transferDiv.appendChild(nameDiv);
            transferDiv.appendChild(progressDiv);
            
            fileTransfers.appendChild(transferDiv);
        }

        function updateFileTransferUI(fileId, status, info) {
            const fileElement = document.getElementById(`file-${fileId}`);
            if (fileElement) {
                fileElement.className = `file-transfer ${status}`;
                if (info) {
                    const hashDiv = document.createElement('div');
                    hashDiv.className = 'file-hash';
                    hashDiv.textContent = info;
                    fileElement.appendChild(hashDiv);
                }
            }
        }

        // ===== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô =====
        startBtn.addEventListener('click', startConnection);
        stopBtn.addEventListener('click', stopConnection);
        copyOfferBtn.addEventListener('click', copyOffer);
        connectBtn.addEventListener('click', connectWithAnswer);
        muteBtn.addEventListener('click', toggleMute);
        volumeBtn.addEventListener('click', toggleVolume);
        sendMessageBtn.addEventListener('click', sendMessage);
        sendFileBtn.addEventListener('click', sendFile);

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å—Ç–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞
        answerText.addEventListener('input', async function() {
            if (this.value && !peerConnection) {
                try {
                    isInitiator = false;
                    log('üöÄ –°—Ç–∞—Ä—Ç—É—é –∫–∞–∫ —Ä–µ—Å–ø–æ–Ω–¥–µ–Ω—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...');
                    
                    const offerBase64 = this.value.trim();
                    const offerJson = decodeURIComponent(escape(atob(offerBase64)));
                    const offer = JSON.parse(offerJson);

                    const keyPair = await generateKeyPair();
                    publicKey = keyPair.publicKey;
                    privateKey = keyPair.privateKey;
                    remotePublicKey = await importPublicKey(offer.publicKey);
                    log('‚úÖ RSA-OAEP –∫–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã, –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω');
                    
                    updateEncryptionStatus('üîë –ö–ª—é—á–∏ –≥–æ—Ç–æ–≤—ã', 'info');

                    localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 48000,
                            channelCount: 2
                        },
                        video: false
                    });
                    log('‚úÖ –ú–∏–∫—Ä–æ—Ñ–æ–Ω –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω');

                    peerConnection = new RTCPeerConnection(rtcConfig);
                    
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });

                    const transceivers = peerConnection.getTransceivers();
                    transceivers.forEach(transceiver => {
                        if (transceiver.sender && transceiver.sender.track && transceiver.sender.track.kind === 'audio') {
                            const parameters = transceiver.sender.getParameters();
                            if (!parameters.encodings) {
                                parameters.encodings = [{}];
                            }
                            parameters.encodings[0].maxBitrate = 510000;
                            transceiver.sender.setParameters(parameters);
                        }
                    });

                    peerConnection.ondatachannel = (event) => {
                        log('üì° Data channel –ø–æ–ª—É—á–µ–Ω');
                        dataChannel = event.channel;
                        setupDataChannel(dataChannel);
                    };

                    peerConnection.ontrack = (event) => {
                        log('‚úÖ –í—Ö–æ–¥—è—â–∏–π –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω');
                        remoteAudio.srcObject = event.streams[0];
                    };

                    await peerConnection.setRemoteDescription(offer.sdp);
                    log('üìù Remote description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');

                    for (const candidate of offer.candidates) {
                        await peerConnection.addIceCandidate(candidate);
                    }
                    log('‚úÖ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã');

                    let iceCandidates = [];
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            iceCandidates.push(event.candidate);
                        }
                    };

                    peerConnection.onicegatheringstatechange = async () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            log('‚úÖ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–±—Ä–∞–Ω—ã');
                            const publicKeyStr = await exportPublicKey(publicKey);
                            const answer = {
                                sdp: peerConnection.localDescription,
                                publicKey: publicKeyStr,
                                candidates: iceCandidates
                            };
                            
                            const answerJson = JSON.stringify(answer);
                            const answerBase64 = btoa(unescape(encodeURIComponent(answerJson)));
                            offerText.value = answerBase64;
                            copyOfferBtn.disabled = false;
                            
                            updateStatus('‚úÖ –û—Ç–≤–µ—Ç —Å–æ–∑–¥–∞–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä—É!', 'success');
                            startBtn.disabled = true;
                            stopBtn.disabled = false;
                            muteBtn.disabled = false;
                            volumeBtn.disabled = false;
                            this.disabled = true;
                        }
                    };

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    log('üìù Answer —Å–æ–∑–¥–∞–Ω');

                    updateStatus('‚è≥ –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞...', 'info');

                } catch (error) {
                    log('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞: ' + error.message);
                    console.error(error);
                }
            }
        });

        log('üöÄ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ. P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å end-to-end —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º –≥–æ—Ç–æ–≤–æ.');
        log('üîê –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: RSA-OAEP 2048 (–æ–±–º–µ–Ω –∫–ª—é—á–∞–º–∏) + AES-GCM 256 (–¥–∞–Ω–Ω—ã–µ) + MD5 (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏)');
    </script>
</body>
</html>
